# 🔹 Destrinchando a Instrução `LDI ACC,6`

## 1. O que é `LDI ACC,6`
- **LDI** = *Load Immediate* → carregar um valor imediato.  
- **ACC** = acumulador (registrador central da CPU).  
- **6** = valor literal (imediato) que vem dentro da própria instrução.  

👉 Objetivo: colocar o número **6** dentro do **acumulador**.

---

## 2. A regra de ouro (barramento)
Dentro da CPU, dados **sempre** se movem assim:
1. **Alguém escreve no barramento** (um `Xout = 1`).  
2. **Alguém lê do barramento** (um `Yin = 1`).  

Esses dois atos **não** acontecem “ao mesmo tempo” — a gente divide em **dois clocks** para garantir que:
- No **Clock 1** o dado esteja **presente** no barramento;
- No **Clock 2** o destino **ainda veja** esse dado e possa **capturar**.

---

## 3. O que é o `ExtDataOut`
- **ExtDataOut** = *External Data Out* → saída dos dados imediatos da instrução.  
- Não é um “componente universal de todo microcontrolador”, mas faz parte desse projeto didático.  
- Função: **liberar o campo imediato da instrução para o barramento de dados**.

👉 Analogia:  
- Barramento = estrada.  
- ExtDataOut = portão que abre e deixa o carro (valor imediato) entrar na estrada.

---

## 4. O `ExtDataOut` é o barramento?
- ❌ Não.  
- O **barramento** é a estrada por onde os dados circulam.  
- O **ExtDataOut** é só o **interruptor** que coloca o valor imediato na estrada.

---

## 5. Eu “ligo” o `ExtDataOut`?
- ✅ Sim.  
- Quando `ExtDataOut = 1`, o valor imediato (ex.: `6`, em binário `00000110`) é colocado no barramento.  
- No próximo clock, outro registrador (como o ACC) habilita sua entrada (`AccIn = 1`) e captura esse valor.

---

## 6. O que é o ACC
- **ACC = Acumulador**.  
- É um **registrador especial**, usado como mesa de trabalho da CPU.  
- Funções:  
  1. Guardar **resultados parciais** (ex.: 6+4=10, que ainda será usado depois).  
  2. Guardar **resultados finais** (ex.: resultado pronto = 8).  
  3. Servir de ponto central para operações da ULA.

👉 Analogia: ACC é a **tábua de corte**: tudo passa por ela, vai sendo transformado, até chegar ao prato final.

---

## 7. O acumulador guarda instruções?
- ❌ Não.  
- Ele não acumula instruções (estas ficam na memória de programa).  
- Ele acumula **dados/resultados** das operações para continuar o processamento.

---

## 8. Sinais relevantes do projeto
- `ExtDataOut`: habilita a **saída do valor imediato** da instrução para o barramento.  
- `AccIn`: habilita a **entrada** do acumulador para capturar o que está no barramento.  

> Dica mental: `Xout` → **coloca** dado na estrada; `Yin` → **pega** o dado da estrada.

---

## 9. Linha do tempo da execução (2 clocks)

| Clock | Sinais em **1**                         | Quem **escreve** no barramento | Quem **lê** | Valor no barramento | Efeito do ciclo |
|------:|-----------------------------------------|---------------------------------|-------------|---------------------|-----------------|
|   1   | `ExtDataOut`                            | Imediato da instrução           | —           | **6**               | O 6 aparece na “estrada” |
|   2   | `ExtDataOut` **(mantém!)**, `AccIn`     | Imediato da instrução           | ACC         | **6**               | ACC captura 6   |

**Por que manter `ExtDataOut` no 2º clock?**  
Porque o ACC só consegue ler se o 6 **ainda estiver** no barramento quando `AccIn` for ativado. Se você desligasse `ExtDataOut` antes, o ACC não veria nada.

---

## 10. Fluxo Visual

Clock 1:
[ Imediato 6 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(ninguém lê)--> [ ACC ]

Clock 2:
[ Imediato 6 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(AccIn=1)-----> [ ACC := 6 ]


Resultado final após os 2 clocks: **ACC = 6**.

---

## 11. Perguntas frequentes (FAQ)

**1) “LDI pega de onde?”**  
Do **campo imediato** da **própria instrução** (codificado em bits dentro do registrador de instrução). `ExtDataOut` é o “porteiro” que libera esse campo para o barramento.

**2) “E se eu esquecer de manter `ExtDataOut` no 2º clock?”**  
O ACC vai tentar ler, mas não haverá dado estável no barramento → **lixo** ou **zero** (dependendo do hardware).  
Regra prática: **Quem escreve no clock 1, mantém no clock 2** se alguém for ler.

**3) “Por que duas metas separadas (1º escreve, 2º lê)?”**  
Para evitar disputa de tempo e garantir estabilidade dos dados. Essa separação é o coração do microciclo.

**4) “LDI altera flags (Zero, Carry)?”**  
Depende do design. Em muitos projetos didáticos, **LDI pode atualizar o flag Z** se o imediato for 0, mas **não mexe em Carry**. Se não implementado, LDI só carrega.

**5) “E se o imediato for maior que 8 bits?”**  
Você pode:
- Carregar em **duas partes** (alto/baixo) com duas instruções LDI, ou  
- Ter uma ULA/barramento mais largos.  
No projeto didático, o imediato tipicamente é **1 byte**.

**6) “E se eu acionar 2 saídas (Xout) no mesmo clock?”**  
Dá **briga no barramento** (contenção). Regra: **apenas uma fonte Xout** por clock.

---

## 12. Erros clássicos
- ❌ Esquecer `AccIn` no 2º clock → ACC não muda.  
- ❌ Não manter `ExtDataOut` no 2º clock → ACC lê valor instável.  
- ❌ Ligar algum `R?out` junto com `ExtDataOut` → disputa no barramento (comportamento imprevisível).

---

## 13. Checklist mental para `LDI ACC,6`
- [ ] No Clock 1, **liguei** `ExtDataOut`.  
- [ ] No Clock 2, **mantive** `ExtDataOut` **e** liguei `AccIn`.  
- [ ] Só **uma** fonte no barramento por clock.  
- [ ] ACC mudou para 6 ao final do Clock 2.
