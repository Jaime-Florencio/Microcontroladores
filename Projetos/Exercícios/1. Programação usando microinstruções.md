# ğŸ”¹ Destrinchando a InstruÃ§Ã£o `LDI ACC,6`

## 1. O que Ã© `LDI ACC,6`
- **LDI** = *Load Immediate* â†’ carregar um valor imediato.  
- **ACC** = acumulador (registrador central da CPU).  
- **6** = valor literal (imediato) que vem dentro da prÃ³pria instruÃ§Ã£o.  

ğŸ‘‰ Objetivo: colocar o nÃºmero **6** dentro do **acumulador**.

---

## 2. A regra de ouro (barramento)
Dentro da CPU, dados **sempre** se movem assim:
1. **AlguÃ©m escreve no barramento** (um `Xout = 1`).  
2. **AlguÃ©m lÃª do barramento** (um `Yin = 1`).  

Esses dois atos **nÃ£o** acontecem â€œao mesmo tempoâ€ â€” a gente divide em **dois clocks** para garantir que:
- No **Clock 1** o dado esteja **presente** no barramento;
- No **Clock 2** o destino **ainda veja** esse dado e possa **capturar**.

---

## 3. O que Ã© o `ExtDataOut`
- **ExtDataOut** = *External Data Out* â†’ saÃ­da dos dados imediatos da instruÃ§Ã£o.  
- NÃ£o Ã© um â€œcomponente universal de todo microcontroladorâ€, mas faz parte desse projeto didÃ¡tico.  
- FunÃ§Ã£o: **liberar o campo imediato da instruÃ§Ã£o para o barramento de dados**.

ğŸ‘‰ Analogia:  
- Barramento = estrada.  
- ExtDataOut = portÃ£o que abre e deixa o carro (valor imediato) entrar na estrada.

---

## 4. O `ExtDataOut` Ã© o barramento?
- âŒ NÃ£o.  
- O **barramento** Ã© a estrada por onde os dados circulam.  
- O **ExtDataOut** Ã© sÃ³ o **interruptor** que coloca o valor imediato na estrada.

---

## 5. Eu â€œligoâ€ o `ExtDataOut`?
- âœ… Sim.  
- Quando `ExtDataOut = 1`, o valor imediato (ex.: `6`, em binÃ¡rio `00000110`) Ã© colocado no barramento.  
- No prÃ³ximo clock, outro registrador (como o ACC) habilita sua entrada (`AccIn = 1`) e captura esse valor.

---

## 6. O que Ã© o ACC
- **ACC = Acumulador**.  
- Ã‰ um **registrador especial**, usado como mesa de trabalho da CPU.  
- FunÃ§Ãµes:  
  1. Guardar **resultados parciais** (ex.: 6+4=10, que ainda serÃ¡ usado depois).  
  2. Guardar **resultados finais** (ex.: resultado pronto = 8).  
  3. Servir de ponto central para operaÃ§Ãµes da ULA.

ğŸ‘‰ Analogia: ACC Ã© a **tÃ¡bua de corte**: tudo passa por ela, vai sendo transformado, atÃ© chegar ao prato final.

---

## 7. O acumulador guarda instruÃ§Ãµes?
- âŒ NÃ£o.  
- Ele nÃ£o acumula instruÃ§Ãµes (estas ficam na memÃ³ria de programa).  
- Ele acumula **dados/resultados** das operaÃ§Ãµes para continuar o processamento.

---

## 8. Sinais relevantes do projeto
- `ExtDataOut`: habilita a **saÃ­da do valor imediato** da instruÃ§Ã£o para o barramento.  
- `AccIn`: habilita a **entrada** do acumulador para capturar o que estÃ¡ no barramento.  

> Dica mental: `Xout` â†’ **coloca** dado na estrada; `Yin` â†’ **pega** o dado da estrada.

---

## 9. Linha do tempo da execuÃ§Ã£o (2 clocks)

| Clock | Sinais em **1**                         | Quem **escreve** no barramento | Quem **lÃª** | Valor no barramento | Efeito do ciclo |
|------:|-----------------------------------------|---------------------------------|-------------|---------------------|-----------------|
|   1   | `ExtDataOut`                            | Imediato da instruÃ§Ã£o           | â€”           | **6**               | O 6 aparece na â€œestradaâ€ |
|   2   | `ExtDataOut` **(mantÃ©m!)**, `AccIn`     | Imediato da instruÃ§Ã£o           | ACC         | **6**               | ACC captura 6   |

**Por que manter `ExtDataOut` no 2Âº clock?**  
Porque o ACC sÃ³ consegue ler se o 6 **ainda estiver** no barramento quando `AccIn` for ativado. Se vocÃª desligasse `ExtDataOut` antes, o ACC nÃ£o veria nada.

---

## 10. Fluxo Visual

Clock 1:
[ Imediato 6 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(ninguÃ©m lÃª)--> [ ACC ]

Clock 2:
[ Imediato 6 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(AccIn=1)-----> [ ACC := 6 ]


Resultado final apÃ³s os 2 clocks: **ACC = 6**.

---

## 11. Perguntas frequentes (FAQ)

**1) â€œLDI pega de onde?â€**  
Do **campo imediato** da **prÃ³pria instruÃ§Ã£o** (codificado em bits dentro do registrador de instruÃ§Ã£o). `ExtDataOut` Ã© o â€œporteiroâ€ que libera esse campo para o barramento.

**2) â€œE se eu esquecer de manter `ExtDataOut` no 2Âº clock?â€**  
O ACC vai tentar ler, mas nÃ£o haverÃ¡ dado estÃ¡vel no barramento â†’ **lixo** ou **zero** (dependendo do hardware).  
Regra prÃ¡tica: **Quem escreve no clock 1, mantÃ©m no clock 2** se alguÃ©m for ler.

**3) â€œPor que duas metas separadas (1Âº escreve, 2Âº lÃª)?â€**  
Para evitar disputa de tempo e garantir estabilidade dos dados. Essa separaÃ§Ã£o Ã© o coraÃ§Ã£o do microciclo.

**4) â€œLDI altera flags (Zero, Carry)?â€**  
Depende do design. Em muitos projetos didÃ¡ticos, **LDI pode atualizar o flag Z** se o imediato for 0, mas **nÃ£o mexe em Carry**. Se nÃ£o implementado, LDI sÃ³ carrega.

**5) â€œE se o imediato for maior que 8 bits?â€**  
VocÃª pode:
- Carregar em **duas partes** (alto/baixo) com duas instruÃ§Ãµes LDI, ou  
- Ter uma ULA/barramento mais largos.  
No projeto didÃ¡tico, o imediato tipicamente Ã© **1 byte**.

**6) â€œE se eu acionar 2 saÃ­das (Xout) no mesmo clock?â€**  
DÃ¡ **briga no barramento** (contenÃ§Ã£o). Regra: **apenas uma fonte Xout** por clock.

---

## 12. Erros clÃ¡ssicos
- âŒ Esquecer `AccIn` no 2Âº clock â†’ ACC nÃ£o muda.  
- âŒ NÃ£o manter `ExtDataOut` no 2Âº clock â†’ ACC lÃª valor instÃ¡vel.  
- âŒ Ligar algum `R?out` junto com `ExtDataOut` â†’ disputa no barramento (comportamento imprevisÃ­vel).

---

## 13. Checklist mental para `LDI ACC,6`
- [ ] No Clock 1, **liguei** `ExtDataOut`.  
- [ ] No Clock 2, **mantive** `ExtDataOut` **e** liguei `AccIn`.  
- [ ] SÃ³ **uma** fonte no barramento por clock.  
- [ ] ACC mudou para 6 ao final do Clock 2.
