# üîπDestrinchando a Instru√ß√£o `LDI ACC,6`

## 1. O que √© `LDI ACC,6`
- **LDI** = *Load Immediate* ‚Üí carregar um valor imediato.  
- **ACC** = acumulador (registrador central da CPU).  
- **6** = valor literal (imediato) que vem dentro da pr√≥pria instru√ß√£o.  

üëâ Objetivo: colocar o n√∫mero **6** dentro do **acumulador**.

---

## 2. A regra de ouro (barramento)
Dentro da CPU, dados **sempre** se movem assim:
1. **Algu√©m escreve no barramento** (um `Xout = 1`).  
2. **Algu√©m l√™ do barramento** (um `Yin = 1`).  

Esses dois atos **n√£o** acontecem ‚Äúao mesmo tempo‚Äù ‚Äî a gente divide em **dois clocks** para garantir que:
- No **Clock 1** o dado esteja **presente** no barramento;
- No **Clock 2** o destino **ainda veja** esse dado e possa **capturar**.

---

## 3. O que √© o `ExtDataOut`
- **ExtDataOut** = *External Data Out* ‚Üí sa√≠da dos dados imediatos da instru√ß√£o.  
- N√£o √© um ‚Äúcomponente universal de todo microcontrolador‚Äù, mas faz parte desse projeto did√°tico.  
- Fun√ß√£o: **liberar o campo imediato da instru√ß√£o para o barramento de dados**.

üëâ Analogia:  
- Barramento = estrada.  
- ExtDataOut = port√£o que abre e deixa o carro (valor imediato) entrar na estrada.

---

## 4. O `ExtDataOut` √© o barramento?
- ‚ùå N√£o.  
- O **barramento** √© a estrada por onde os dados circulam.  
- O **ExtDataOut** √© s√≥ o **interruptor** que coloca o valor imediato na estrada.

---

## 5. Eu ‚Äúligo‚Äù o `ExtDataOut`?
- ‚úÖ Sim.  
- Quando `ExtDataOut = 1`, o valor imediato (ex.: `6`, em bin√°rio `00000110`) √© colocado no barramento.  
- No pr√≥ximo clock, outro registrador (como o ACC) habilita sua entrada (`AccIn = 1`) e captura esse valor.

---

## 6. O que √© o ACC
- **ACC = Acumulador**.  
- √â um **registrador especial**, usado como mesa de trabalho da CPU.  
- Fun√ß√µes:  
  1. Guardar **resultados parciais** (ex.: 6+4=10, que ainda ser√° usado depois).  
  2. Guardar **resultados finais** (ex.: resultado pronto = 8).  
  3. Servir de ponto central para opera√ß√µes da ULA.

üëâ Analogia: ACC √© a **t√°bua de corte**: tudo passa por ela, vai sendo transformado, at√© chegar ao prato final.

---

## 7. O acumulador guarda instru√ß√µes?
- ‚ùå N√£o.  
- Ele n√£o acumula instru√ß√µes (estas ficam na mem√≥ria de programa).  
- Ele acumula **dados/resultados** das opera√ß√µes para continuar o processamento.

---

## 8. Sinais relevantes do projeto
- `ExtDataOut`: habilita a **sa√≠da do valor imediato** da instru√ß√£o para o barramento.  
- `AccIn`: habilita a **entrada** do acumulador para capturar o que est√° no barramento.  

> Dica mental: `Xout` ‚Üí **coloca** dado na estrada; `Yin` ‚Üí **pega** o dado da estrada.

---

## 9. Linha do tempo da execu√ß√£o (2 clocks)

| Clock | Sinais em **1**                         | Quem **escreve** no barramento | Quem **l√™** | Valor no barramento | Efeito do ciclo |
|------:|-----------------------------------------|---------------------------------|-------------|---------------------|-----------------|
|   1   | `ExtDataOut`                            | Imediato da instru√ß√£o           | ‚Äî           | **6**               | O 6 aparece na ‚Äúestrada‚Äù |
|   2   | `ExtDataOut` **(mant√©m!)**, `AccIn`     | Imediato da instru√ß√£o           | ACC         | **6**               | ACC captura 6   |

**Por que manter `ExtDataOut` no 2¬∫ clock?**  
Porque o ACC s√≥ consegue ler se o 6 **ainda estiver** no barramento quando `AccIn` for ativado. Se voc√™ desligasse `ExtDataOut` antes, o ACC n√£o veria nada.

---

## 10. Fluxo Visual

Clock 1:
[ Imediato 6 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(ningu√©m l√™)--> [ ACC ]

Clock 2:
[ Imediato 6 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(AccIn=1)-----> [ ACC := 6 ]


Resultado final ap√≥s os 2 clocks: **ACC = 6**.

---

## 11. Perguntas frequentes (FAQ)

**1) ‚ÄúLDI pega de onde?‚Äù**  
Do **campo imediato** da **pr√≥pria instru√ß√£o** (codificado em bits dentro do registrador de instru√ß√£o). `ExtDataOut` √© o ‚Äúporteiro‚Äù que libera esse campo para o barramento.

**2) ‚ÄúE se eu esquecer de manter `ExtDataOut` no 2¬∫ clock?‚Äù**  
O ACC vai tentar ler, mas n√£o haver√° dado est√°vel no barramento ‚Üí **lixo** ou **zero** (dependendo do hardware).  
Regra pr√°tica: **Quem escreve no clock 1, mant√©m no clock 2** se algu√©m for ler.

**3) ‚ÄúPor que duas metas separadas (1¬∫ escreve, 2¬∫ l√™)?‚Äù**  
Para evitar disputa de tempo e garantir estabilidade dos dados. Essa separa√ß√£o √© o cora√ß√£o do microciclo.

**4) ‚ÄúLDI altera flags (Zero, Carry)?‚Äù**  
Depende do design. Em muitos projetos did√°ticos, **LDI pode atualizar o flag Z** se o imediato for 0, mas **n√£o mexe em Carry**. Se n√£o implementado, LDI s√≥ carrega.

**5) ‚ÄúE se o imediato for maior que 8 bits?‚Äù**  
Voc√™ pode:
- Carregar em **duas partes** (alto/baixo) com duas instru√ß√µes LDI, ou  
- Ter uma ULA/barramento mais largos.  
No projeto did√°tico, o imediato tipicamente √© **1 byte**.

**6) ‚ÄúE se eu acionar 2 sa√≠das (Xout) no mesmo clock?‚Äù**  
D√° **briga no barramento** (conten√ß√£o). Regra: **apenas uma fonte Xout** por clock.

---

## 12. Erros cl√°ssicos
- ‚ùå Esquecer `AccIn` no 2¬∫ clock ‚Üí ACC n√£o muda.  
- ‚ùå N√£o manter `ExtDataOut` no 2¬∫ clock ‚Üí ACC l√™ valor inst√°vel.  
- ‚ùå Ligar algum `R?out` junto com `ExtDataOut` ‚Üí disputa no barramento (comportamento imprevis√≠vel).

---

## 13. Checklist mental para `LDI ACC,6`
- [ ] No Clock 1, **liguei** `ExtDataOut`.  
- [ ] No Clock 2, **mantive** `ExtDataOut` **e** liguei `AccIn`.  
- [ ] S√≥ **uma** fonte no barramento por clock.  
- [ ] ACC mudou para 6 ao final do Clock 2.

---

# üîπDestrinchando a Instru√ß√£o `LDI R1,4`

## 1. O que √© `LDI R1,4`
- **LDI** = *Load Immediate* ‚Üí carregar um valor imediato.  
- **R1** = registrador de prop√≥sito geral (uma das ‚Äúgavetas‚Äù r√°pidas da CPU).  
- **4** = valor literal (imediato) que vem dentro da pr√≥pria instru√ß√£o.  

üëâ Objetivo: colocar o n√∫mero **4** dentro do **registrador R1**.

---

## 2. A regra de ouro (barramento)
Dentro da CPU, dados **sempre** se movem assim:
1. **Algu√©m escreve no barramento** (um `Xout = 1`).  
2. **Algu√©m l√™ do barramento** (um `Yin = 1`).  

Esses dois atos s√£o separados em **dois clocks** para garantir estabilidade:
- **Clock 1:** o dado aparece no barramento.  
- **Clock 2:** o dado continua l√°, e o destino captura.

---

## 3. O que √© o `ExtDataOut`
- √â o sinal que libera o campo imediato da instru√ß√£o para o barramento.  
- No caso do `LDI R1,4`, o valor **4** (em bin√°rio `00000100`) vai para o barramento.

üëâ Analogia: port√£o que abre e coloca o carro ‚Äú4‚Äù na estrada.

---

## 4. O que √© o `R1in`
- √â o sinal que habilita a **entrada** do registrador R1.  
- Quando est√° em `1`, R1 captura o valor que est√° no barramento.

---

## 5. Linha do tempo da execu√ß√£o (2 clocks)

| Clock | Sinais em **1**                         | Quem **escreve** no barramento | Quem **l√™** | Valor no barramento | Efeito do ciclo |
|------:|-----------------------------------------|---------------------------------|-------------|---------------------|-----------------|
|   1   | `ExtDataOut`                            | Imediato da instru√ß√£o           | ‚Äî           | **4**               | O 4 aparece na ‚Äúestrada‚Äù |
|   2   | `ExtDataOut` **(mant√©m!)**, `R1in`      | Imediato da instru√ß√£o           | R1          | **4**               | R1 captura 4    |

**Por que manter `ExtDataOut` no 2¬∫ clock?**  
Porque o R1 s√≥ consegue ler se o 4 **ainda estiver** no barramento quando `R1in` for ativado.  

---

## 6. Fluxo Visual

Clock 1:
[ Imediato 4 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(ningu√©m l√™)--> [ R1 ]

Clock 2:
[ Imediato 4 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(R1in=1)-----> [ R1 := 4 ]


Resultado final ap√≥s os 2 clocks: **R1 = 4**.

---

## 7. Perguntas frequentes (FAQ)

**1) ‚ÄúDe onde vem o 4?‚Äù**  
Do campo imediato da pr√≥pria instru√ß√£o (bits guardados no registrador de instru√ß√£o).

**2) ‚ÄúO ACC participa?‚Äù**  
‚ùå N√£o. Aqui o destino √© R1, ent√£o s√≥ `R1in` √© usado.  

**3) ‚ÄúE se eu ligar `R1in` no primeiro clock?‚Äù**  
Ele pode ler valor inst√°vel, porque o barramento ainda n√£o tinha certeza do dado. Por isso a entrada sempre vem **no clock seguinte**.

**4) ‚ÄúIsso vale para R2, R3, etc.?‚Äù**  
‚úÖ Sim! `LDI R2,X` e `LDI R3,Y` seguem exatamente o mesmo padr√£o, s√≥ trocando o registrador de destino.

---

## 8. Checklist mental para `LDI R1,4`
- [ ] No Clock 1, **liguei** `ExtDataOut`.  
- [ ] No Clock 2, **mantive** `ExtDataOut` **e** liguei `R1in`.  
- [ ] S√≥ **uma** fonte no barramento por clock.  
- [ ] R1 mudou para 4 ao final do Clock 2.

---

# üîπ Destrinchando as Instru√ß√µes `LDI R2,5` e `LDI R3,10`

## 1. O que s√£o
- **LDI** = *Load Immediate* ‚Üí carregar um valor imediato.  
- **R2** e **R3** = registradores de prop√≥sito geral (gavetas r√°pidas da CPU).  
- **5** e **10** = valores literais (imediatos) que v√™m dentro da pr√≥pria instru√ß√£o.  

üëâ Objetivo: colocar os n√∫meros **5** e **10** nos registradores **R2** e **R3**, respectivamente.  

---

## 2. A l√≥gica √© a mesma do `LDI ACC,6` e `LDI R1,4`
Dentro da CPU, dados sempre se movem em **dois clocks**:  
1. **Clock 1:** o valor imediato vai para o barramento (`ExtDataOut = 1`).  
2. **Clock 2:** o valor se mant√©m no barramento (`ExtDataOut = 1`) e o registrador de destino habilita a entrada (`R2in` ou `R3in`).  

---

## 3. Linha do tempo da execu√ß√£o

### `LDI R2,5`

| Clock | Sinais em **1**                         | Quem **escreve** | Quem **l√™** | Valor no barramento | Efeito |
|------:|-----------------------------------------|------------------|-------------|---------------------|--------|
|   1   | `ExtDataOut`                            | Imediato (5)     | ‚Äî           | **5**               | 5 aparece na estrada |
|   2   | `ExtDataOut` (mant√©m), `R2in`           | Imediato (5)     | R2          | **5**               | R2 captura 5 |

üëâ Resultado final: **R2 = 5**.

---

### `LDI R3,10`

| Clock | Sinais em **1**                         | Quem **escreve** | Quem **l√™** | Valor no barramento | Efeito |
|------:|-----------------------------------------|------------------|-------------|---------------------|--------|
|   1   | `ExtDataOut`                            | Imediato (10)    | ‚Äî           | **10**              | 10 aparece na estrada |
|   2   | `ExtDataOut` (mant√©m), `R3in`           | Imediato (10)    | R3          | **10**              | R3 captura 10 |

üëâ Resultado final: **R3 = 10**.

---

## 4. Fluxo Visual (igual para R2 e R3, s√≥ muda o destino)

Clock 1:
[ Imediato X ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(ningu√©m l√™)--> [ R? ]

Clock 2:
[ Imediato X ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(R?in=1)-----> [ R? := X ]


---

## 5. Resumindo
- **LDI R2,5** ‚Üí coloca o valor imediato 5 em R2.  
- **LDI R3,10** ‚Üí coloca o valor imediato 10 em R3.  
- Ambos seguem exatamente a mesma l√≥gica j√° explicada para `LDI ACC,6` e `LDI R1,4`.  
- O que muda √© apenas o **registrador de destino** (`R2in` ou `R3in`).

---

# üîπ Registradores no Projeto Did√°tico

## 1. O que √© um registrador
- Um **registrador** √© uma **pequena mem√≥ria dentro da CPU**.  
- Ele armazena uma **palavra** (um conjunto de bits, ex.: 8 bits = 1 byte).  
- Os registradores s√£o **vol√°teis** ‚Üí ou seja, perdem o conte√∫do quando a CPU √© desligada.  
- Fun√ß√£o principal: **guardar dados tempor√°rios para opera√ß√µes**.

üëâ Pense nos registradores como **gavetas muito r√°pidas** que a CPU usa durante o processamento.

---

## 2. ACC (Acumulador)
- **Nome:** ACC = *Accumulator*.  
- **Fun√ß√£o:** registrador **principal** para guardar resultados das opera√ß√µes.  
- Chamamos de ‚Äúacumulador‚Äù porque ele **acumula os resultados parciais e finais**.  
- Exemplo:  
  - `LDI ACC,6` ‚Üí ACC = 6  
  - `ADD ACC,AUX` ‚Üí ACC = ACC + AUX  

üëâ Ele √© o **cora√ß√£o da ULA**, quase toda opera√ß√£o passa por ele.

---

## 3. AUX (Auxiliar)
- **Nome:** AUX = registrador auxiliar.  
- **Fun√ß√£o:** segurar o **outro operando** para opera√ß√µes da ULA.  
- Trabalha sempre em conjunto com o ACC.  
- Exemplo:  
  - `MOV AUX,R1` ‚Üí AUX = R1  
  - `ADD ACC,AUX` ‚Üí ACC = ACC + AUX  

üëâ Diferen√ßa b√°sica:
- **ACC** ‚Üí recebe sempre o resultado.  
- **AUX** ‚Üí serve como apoio (segundo valor da opera√ß√£o).

---

## 4. R1, R2, R3 (Registradores de Prop√≥sito Geral)
- S√£o registradores comuns, tipo **gavetas extras** para guardar valores.  
- Eles n√£o t√™m papel ‚Äúespecial‚Äù como ACC e AUX, mas s√£o usados como **fonte de dados**.  
- Exemplo:  
  - `LDI R1,4` ‚Üí R1 = 4  
  - `MOV AUX,R1` ‚Üí AUX = R1  

üëâ Eles d√£o flexibilidade: voc√™ pode armazenar dados intermedi√°rios sem precisar sobrecarregar o ACC.

---

## 5. Compara√ß√£o ACC x AUX x R1/R2/R3

| Registrador | Fun√ß√£o principal | Papel t√≠pico |
|-------------|-----------------|--------------|
| **ACC**    | Acumular resultados (parciais e finais) | Sa√≠da da maioria das opera√ß√µes |
| **AUX**    | Guardar o segundo operando da ULA | Apoio para somas, subtra√ß√µes, opera√ß√µes l√≥gicas |
| **R1,R2,R3** | Armazenar dados de prop√≥sito geral | Fonte de valores para mover/copiar |

---

## 6. Registrador de deslocamento?
- ‚ùå N√£o.  
- O **AUX n√£o √© um registrador de deslocamento** (shift register).  
- Ele √© s√≥ mais um registrador de uso interno para opera√ß√µes.  
- Registradores de deslocamento s√£o outro tipo de circuito (servem para mover bits para esquerda/direita).

---

## 7. Resumindo
- Todos (ACC, AUX, R1, R2, R3) s√£o **registradores vol√°teis** (perdem o conte√∫do ao desligar).  
- **ACC** = onde o resultado das opera√ß√µes vai parar.  
- **AUX** = apoio, segura o outro valor que a ULA precisa.  
- **R1, R2, R3** = armazenam valores gerais, servem de fonte para mover/copiar.

---

# üîπ Destrinchando a Instru√ß√£o `MOV AUX,R1`

## 1. O que √© `MOV AUX,R1`
- **MOV** = *Move* ‚Üí copiar dados de uma fonte para um destino.  
- **AUX** = registrador auxiliar (apoio para opera√ß√µes com ACC).  
- **R1** = registrador de prop√≥sito geral (fonte do dado).  

üëâ Objetivo: **copiar o conte√∫do de R1 para o AUX**.  
Diferente do `LDI`, aqui o dado **n√£o vem da instru√ß√£o** (imediato), mas sim de **outro registrador**.

---

## 2. A l√≥gica do MOV
- Toda opera√ß√£o dentro da CPU passa pelo **barramento**.  
- Para mover dados:  
  1. **Clock 1:** a fonte coloca o valor no barramento (`R1out = 1`).  
  2. **Clock 2:** a fonte mant√©m o valor, e o destino habilita a entrada (`AuxIn = 1`).  

üëâ Resultado: AUX recebe o valor que estava em R1.

---

## 3. Linha do tempo da execu√ß√£o (2 clocks)

| Clock | Sinais em **1**                         | Quem **escreve** | Quem **l√™** | Valor no barramento | Efeito |
|------:|-----------------------------------------|------------------|-------------|---------------------|--------|
|   1   | `R1out`                                 | R1               | ‚Äî           | valor de R1         | Valor de R1 aparece na estrada |
|   2   | `R1out` (mant√©m), `AuxIn`               | R1               | AUX         | valor de R1         | AUX captura valor de R1 |

üëâ Resultado final: **AUX = R1**.  

---

## 4. Diferen√ßa entre `LDI` e `MOV`
- **LDI** ‚Üí pega um **valor imediato** escrito na instru√ß√£o (`ExtDataOut`).  
- **MOV** ‚Üí copia de um **registrador fonte** (`R1out`, `R2out`, `R3out`) para um **registrador destino** (`AuxIn`, `AccIn`, etc.).  

üëâ Em resumo:  
- `LDI` = carrega n√∫mero fixo.  
- `MOV` = transfere valor j√° existente entre registradores.

---

## 5. Fluxo Visual

Clock 1:
[ R1 ] --(R1out=1)--> [ BARRAMENTO ] --(ningu√©m l√™)--> [ AUX ]

Clock 2:
[ R1 ] --(R1out=1)--> [ BARRAMENTO ] --(AuxIn=1)-----> [ AUX := R1 ]


---

## 6. Perguntas Frequentes (FAQ)

**1) O que √© o AUX?**  
√â um registrador auxiliar que trabalha em conjunto com o ACC para opera√ß√µes aritm√©ticas e l√≥gicas.  
Exemplo: em um `ADD ACC,AUX`, a ULA soma o valor do ACC com o do AUX.

**2) O MOV altera o valor de R1?**  
‚ùå N√£o.  
`MOV AUX,R1` apenas **copia** ‚Üí o R1 continua com o mesmo valor, s√≥ o AUX passa a ter uma c√≥pia.

**3) Por que preciso do AUX se j√° tenho o ACC?**  
Porque muitas opera√ß√µes da ULA s√£o **bin√°rias** (precisam de dois operandos).  
- Exemplo: ACC + AUX.  
- O ACC guarda o primeiro valor, o AUX guarda o segundo, e a ULA faz a opera√ß√£o.

---

## 7. Checklist mental para `MOV AUX,R1`
- [ ] No Clock 1, **liguei** `R1out`.  
- [ ] No Clock 2, **mantive** `R1out` **e** liguei `AuxIn`.  
- [ ] S√≥ **uma** fonte no barramento por clock.  
- [ ] AUX mudou para o valor de R1 ao final do Clock 2.







