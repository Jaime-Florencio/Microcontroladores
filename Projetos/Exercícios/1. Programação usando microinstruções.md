# ðŸ”¹Destrinchando a InstruÃ§Ã£o `LDI ACC,6`

## 1. O que Ã© `LDI ACC,6`
- **LDI** = *Load Immediate* â†’ carregar um valor imediato.  
- **ACC** = acumulador (registrador central da CPU).  
- **6** = valor literal (imediato) que vem dentro da prÃ³pria instruÃ§Ã£o.  

ðŸ‘‰ Objetivo: colocar o nÃºmero **6** dentro do **acumulador**.

---

## 2. A regra de ouro (barramento)
Dentro da CPU, dados **sempre** se movem assim:
1. **AlguÃ©m escreve no barramento** (um `Xout = 1`).  
2. **AlguÃ©m lÃª do barramento** (um `Yin = 1`).  

Esses dois atos **nÃ£o** acontecem â€œao mesmo tempoâ€ â€” a gente divide em **dois clocks** para garantir que:
- No **Clock 1** o dado esteja **presente** no barramento;
- No **Clock 2** o destino **ainda veja** esse dado e possa **capturar**.

---

## 3. O que Ã© o `ExtDataOut`
- **ExtDataOut** = *External Data Out* â†’ saÃ­da dos dados imediatos da instruÃ§Ã£o.  
- NÃ£o Ã© um â€œcomponente universal de todo microcontroladorâ€, mas faz parte desse projeto didÃ¡tico.  
- FunÃ§Ã£o: **liberar o campo imediato da instruÃ§Ã£o para o barramento de dados**.

ðŸ‘‰ Analogia:  
- Barramento = estrada.  
- ExtDataOut = portÃ£o que abre e deixa o carro (valor imediato) entrar na estrada.

---

## 4. O `ExtDataOut` Ã© o barramento?
- âŒ NÃ£o.  
- O **barramento** Ã© a estrada por onde os dados circulam.  
- O **ExtDataOut** Ã© sÃ³ o **interruptor** que coloca o valor imediato na estrada.

---

## 5. Eu â€œligoâ€ o `ExtDataOut`?
- âœ… Sim.  
- Quando `ExtDataOut = 1`, o valor imediato (ex.: `6`, em binÃ¡rio `00000110`) Ã© colocado no barramento.  
- No prÃ³ximo clock, outro registrador (como o ACC) habilita sua entrada (`AccIn = 1`) e captura esse valor.

---

## 6. O que Ã© o ACC
- **ACC = Acumulador**.  
- Ã‰ um **registrador especial**, usado como mesa de trabalho da CPU.  
- FunÃ§Ãµes:  
  1. Guardar **resultados parciais** (ex.: 6+4=10, que ainda serÃ¡ usado depois).  
  2. Guardar **resultados finais** (ex.: resultado pronto = 8).  
  3. Servir de ponto central para operaÃ§Ãµes da ULA.

ðŸ‘‰ Analogia: ACC Ã© a **tÃ¡bua de corte**: tudo passa por ela, vai sendo transformado, atÃ© chegar ao prato final.

---

## 7. O acumulador guarda instruÃ§Ãµes?
- âŒ NÃ£o.  
- Ele nÃ£o acumula instruÃ§Ãµes (estas ficam na memÃ³ria de programa).  
- Ele acumula **dados/resultados** das operaÃ§Ãµes para continuar o processamento.

---

## 8. Sinais relevantes do projeto
- `ExtDataOut`: habilita a **saÃ­da do valor imediato** da instruÃ§Ã£o para o barramento.  
- `AccIn`: habilita a **entrada** do acumulador para capturar o que estÃ¡ no barramento.  

> Dica mental: `Xout` â†’ **coloca** dado na estrada; `Yin` â†’ **pega** o dado da estrada.

---

## 9. Linha do tempo da execuÃ§Ã£o (2 clocks)

| Clock | Sinais em **1**                         | Quem **escreve** no barramento | Quem **lÃª** | Valor no barramento | Efeito do ciclo |
|------:|-----------------------------------------|---------------------------------|-------------|---------------------|-----------------|
|   1   | `ExtDataOut`                            | Imediato da instruÃ§Ã£o           | â€”           | **6**               | O 6 aparece na â€œestradaâ€ |
|   2   | `ExtDataOut` **(mantÃ©m!)**, `AccIn`     | Imediato da instruÃ§Ã£o           | ACC         | **6**               | ACC captura 6   |

**Por que manter `ExtDataOut` no 2Âº clock?**  
Porque o ACC sÃ³ consegue ler se o 6 **ainda estiver** no barramento quando `AccIn` for ativado. Se vocÃª desligasse `ExtDataOut` antes, o ACC nÃ£o veria nada.

---

## 10. Fluxo Visual

Clock 1:
[ Imediato 6 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(ninguÃ©m lÃª)--> [ ACC ]

Clock 2:
[ Imediato 6 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(AccIn=1)-----> [ ACC := 6 ]


Resultado final apÃ³s os 2 clocks: **ACC = 6**.

---

## 11. Perguntas frequentes (FAQ)

**1) â€œLDI pega de onde?â€**  
Do **campo imediato** da **prÃ³pria instruÃ§Ã£o** (codificado em bits dentro do registrador de instruÃ§Ã£o). `ExtDataOut` Ã© o â€œporteiroâ€ que libera esse campo para o barramento.

**2) â€œE se eu esquecer de manter `ExtDataOut` no 2Âº clock?â€**  
O ACC vai tentar ler, mas nÃ£o haverÃ¡ dado estÃ¡vel no barramento â†’ **lixo** ou **zero** (dependendo do hardware).  
Regra prÃ¡tica: **Quem escreve no clock 1, mantÃ©m no clock 2** se alguÃ©m for ler.

**3) â€œPor que duas metas separadas (1Âº escreve, 2Âº lÃª)?â€**  
Para evitar disputa de tempo e garantir estabilidade dos dados. Essa separaÃ§Ã£o Ã© o coraÃ§Ã£o do microciclo.

**4) â€œLDI altera flags (Zero, Carry)?â€**  
Depende do design. Em muitos projetos didÃ¡ticos, **LDI pode atualizar o flag Z** se o imediato for 0, mas **nÃ£o mexe em Carry**. Se nÃ£o implementado, LDI sÃ³ carrega.

**5) â€œE se o imediato for maior que 8 bits?â€**  
VocÃª pode:
- Carregar em **duas partes** (alto/baixo) com duas instruÃ§Ãµes LDI, ou  
- Ter uma ULA/barramento mais largos.  
No projeto didÃ¡tico, o imediato tipicamente Ã© **1 byte**.

**6) â€œE se eu acionar 2 saÃ­das (Xout) no mesmo clock?â€**  
DÃ¡ **briga no barramento** (contenÃ§Ã£o). Regra: **apenas uma fonte Xout** por clock.

---

## 12. Erros clÃ¡ssicos
- âŒ Esquecer `AccIn` no 2Âº clock â†’ ACC nÃ£o muda.  
- âŒ NÃ£o manter `ExtDataOut` no 2Âº clock â†’ ACC lÃª valor instÃ¡vel.  
- âŒ Ligar algum `R?out` junto com `ExtDataOut` â†’ disputa no barramento (comportamento imprevisÃ­vel).

---

## 13. Checklist mental para `LDI ACC,6`
- [ ] No Clock 1, **liguei** `ExtDataOut`.  
- [ ] No Clock 2, **mantive** `ExtDataOut` **e** liguei `AccIn`.  
- [ ] SÃ³ **uma** fonte no barramento por clock.  
- [ ] ACC mudou para 6 ao final do Clock 2.

---

# ðŸ”¹Destrinchando a InstruÃ§Ã£o `LDI R1,4`

## 1. O que Ã© `LDI R1,4`
- **LDI** = *Load Immediate* â†’ carregar um valor imediato.  
- **R1** = registrador de propÃ³sito geral (uma das â€œgavetasâ€ rÃ¡pidas da CPU).  
- **4** = valor literal (imediato) que vem dentro da prÃ³pria instruÃ§Ã£o.  

ðŸ‘‰ Objetivo: colocar o nÃºmero **4** dentro do **registrador R1**.

---

## 2. A regra de ouro (barramento)
Dentro da CPU, dados **sempre** se movem assim:
1. **AlguÃ©m escreve no barramento** (um `Xout = 1`).  
2. **AlguÃ©m lÃª do barramento** (um `Yin = 1`).  

Esses dois atos sÃ£o separados em **dois clocks** para garantir estabilidade:
- **Clock 1:** o dado aparece no barramento.  
- **Clock 2:** o dado continua lÃ¡, e o destino captura.

---

## 3. O que Ã© o `ExtDataOut`
- Ã‰ o sinal que libera o campo imediato da instruÃ§Ã£o para o barramento.  
- No caso do `LDI R1,4`, o valor **4** (em binÃ¡rio `00000100`) vai para o barramento.

ðŸ‘‰ Analogia: portÃ£o que abre e coloca o carro â€œ4â€ na estrada.

---

## 4. O que Ã© o `R1in`
- Ã‰ o sinal que habilita a **entrada** do registrador R1.  
- Quando estÃ¡ em `1`, R1 captura o valor que estÃ¡ no barramento.

---

## 5. Linha do tempo da execuÃ§Ã£o (2 clocks)

| Clock | Sinais em **1**                         | Quem **escreve** no barramento | Quem **lÃª** | Valor no barramento | Efeito do ciclo |
|------:|-----------------------------------------|---------------------------------|-------------|---------------------|-----------------|
|   1   | `ExtDataOut`                            | Imediato da instruÃ§Ã£o           | â€”           | **4**               | O 4 aparece na â€œestradaâ€ |
|   2   | `ExtDataOut` **(mantÃ©m!)**, `R1in`      | Imediato da instruÃ§Ã£o           | R1          | **4**               | R1 captura 4    |

**Por que manter `ExtDataOut` no 2Âº clock?**  
Porque o R1 sÃ³ consegue ler se o 4 **ainda estiver** no barramento quando `R1in` for ativado.  

---

## 6. Fluxo Visual

Clock 1:
[ Imediato 4 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(ninguÃ©m lÃª)--> [ R1 ]

Clock 2:
[ Imediato 4 ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(R1in=1)-----> [ R1 := 4 ]


Resultado final apÃ³s os 2 clocks: **R1 = 4**.

---

## 7. Perguntas frequentes (FAQ)

**1) â€œDe onde vem o 4?â€**  
Do campo imediato da prÃ³pria instruÃ§Ã£o (bits guardados no registrador de instruÃ§Ã£o).

**2) â€œO ACC participa?â€**  
âŒ NÃ£o. Aqui o destino Ã© R1, entÃ£o sÃ³ `R1in` Ã© usado.  

**3) â€œE se eu ligar `R1in` no primeiro clock?â€**  
Ele pode ler valor instÃ¡vel, porque o barramento ainda nÃ£o tinha certeza do dado. Por isso a entrada sempre vem **no clock seguinte**.

**4) â€œIsso vale para R2, R3, etc.?â€**  
âœ… Sim! `LDI R2,X` e `LDI R3,Y` seguem exatamente o mesmo padrÃ£o, sÃ³ trocando o registrador de destino.

---

## 8. Checklist mental para `LDI R1,4`
- [ ] No Clock 1, **liguei** `ExtDataOut`.  
- [ ] No Clock 2, **mantive** `ExtDataOut` **e** liguei `R1in`.  
- [ ] SÃ³ **uma** fonte no barramento por clock.  
- [ ] R1 mudou para 4 ao final do Clock 2.

---

# ðŸ”¹ Destrinchando as InstruÃ§Ãµes `LDI R2,5` e `LDI R3,10`

## 1. O que sÃ£o
- **LDI** = *Load Immediate* â†’ carregar um valor imediato.  
- **R2** e **R3** = registradores de propÃ³sito geral (gavetas rÃ¡pidas da CPU).  
- **5** e **10** = valores literais (imediatos) que vÃªm dentro da prÃ³pria instruÃ§Ã£o.  

ðŸ‘‰ Objetivo: colocar os nÃºmeros **5** e **10** nos registradores **R2** e **R3**, respectivamente.  

---

## 2. A lÃ³gica Ã© a mesma do `LDI ACC,6` e `LDI R1,4`
Dentro da CPU, dados sempre se movem em **dois clocks**:  
1. **Clock 1:** o valor imediato vai para o barramento (`ExtDataOut = 1`).  
2. **Clock 2:** o valor se mantÃ©m no barramento (`ExtDataOut = 1`) e o registrador de destino habilita a entrada (`R2in` ou `R3in`).  

---

## 3. Linha do tempo da execuÃ§Ã£o

### `LDI R2,5`

| Clock | Sinais em **1**                         | Quem **escreve** | Quem **lÃª** | Valor no barramento | Efeito |
|------:|-----------------------------------------|------------------|-------------|---------------------|--------|
|   1   | `ExtDataOut`                            | Imediato (5)     | â€”           | **5**               | 5 aparece na estrada |
|   2   | `ExtDataOut` (mantÃ©m), `R2in`           | Imediato (5)     | R2          | **5**               | R2 captura 5 |

ðŸ‘‰ Resultado final: **R2 = 5**.

---

### `LDI R3,10`

| Clock | Sinais em **1**                         | Quem **escreve** | Quem **lÃª** | Valor no barramento | Efeito |
|------:|-----------------------------------------|------------------|-------------|---------------------|--------|
|   1   | `ExtDataOut`                            | Imediato (10)    | â€”           | **10**              | 10 aparece na estrada |
|   2   | `ExtDataOut` (mantÃ©m), `R3in`           | Imediato (10)    | R3          | **10**              | R3 captura 10 |

ðŸ‘‰ Resultado final: **R3 = 10**.

---

## 4. Fluxo Visual (igual para R2 e R3, sÃ³ muda o destino)

Clock 1:
[ Imediato X ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(ninguÃ©m lÃª)--> [ R? ]

Clock 2:
[ Imediato X ] --(ExtDataOut=1)--> [ BARRAMENTO ] --(R?in=1)-----> [ R? := X ]


---

## 5. Resumindo
- **LDI R2,5** â†’ coloca o valor imediato 5 em R2.  
- **LDI R3,10** â†’ coloca o valor imediato 10 em R3.  
- Ambos seguem exatamente a mesma lÃ³gica jÃ¡ explicada para `LDI ACC,6` e `LDI R1,4`.  
- O que muda Ã© apenas o **registrador de destino** (`R2in` ou `R3in`).

---

# ðŸ”¹ PossÃ­veis ->DÃºvidas<- que surgiram sobre os tipos de registradores: 

## 1. O que Ã© um registrador
- Um **registrador** Ã© uma **pequena memÃ³ria dentro da CPU**.  
- Ele armazena uma **palavra** (um conjunto de bits, ex.: 8 bits = 1 byte).  
- Os registradores sÃ£o **volÃ¡teis** â†’ ou seja, perdem o conteÃºdo quando a CPU Ã© desligada.  
- FunÃ§Ã£o principal: **guardar dados temporÃ¡rios para operaÃ§Ãµes**.

ðŸ‘‰ Pense nos registradores como **gavetas muito rÃ¡pidas** que a CPU usa durante o processamento.

---

## 2. ACC (Acumulador)
- **Nome:** ACC = *Accumulator*.  
- **FunÃ§Ã£o:** registrador **principal** para guardar resultados das operaÃ§Ãµes.  
- Chamamos de â€œacumuladorâ€ porque ele **acumula os resultados parciais e finais**.  
- Exemplo:  
  - `LDI ACC,6` â†’ ACC = 6  
  - `ADD ACC,AUX` â†’ ACC = ACC + AUX  

ðŸ‘‰ Ele Ã© o **coraÃ§Ã£o da ULA**, quase toda operaÃ§Ã£o passa por ele.

---

## 3. AUX (Auxiliar)
- **Nome:** AUX = registrador auxiliar.  
- **FunÃ§Ã£o:** segurar o **outro operando** para operaÃ§Ãµes da ULA.  
- Trabalha sempre em conjunto com o ACC.  
- Exemplo:  
  - `MOV AUX,R1` â†’ AUX = R1  
  - `ADD ACC,AUX` â†’ ACC = ACC + AUX  

ðŸ‘‰ DiferenÃ§a bÃ¡sica:
- **ACC** â†’ recebe sempre o resultado.  
- **AUX** â†’ serve como apoio (segundo valor da operaÃ§Ã£o).

---

## 4. R1, R2, R3 (Registradores de PropÃ³sito Geral)
- SÃ£o registradores comuns, tipo **gavetas extras** para guardar valores.  
- Eles nÃ£o tÃªm papel â€œespecialâ€ como ACC e AUX, mas sÃ£o usados como **fonte de dados**.  
- Exemplo:  
  - `LDI R1,4` â†’ R1 = 4  
  - `MOV AUX,R1` â†’ AUX = R1  

ðŸ‘‰ Eles dÃ£o flexibilidade: vocÃª pode armazenar dados intermediÃ¡rios sem precisar sobrecarregar o ACC.

---

## 5. ComparaÃ§Ã£o ACC x AUX x R1/R2/R3

| Registrador | FunÃ§Ã£o principal | Papel tÃ­pico |
|-------------|-----------------|--------------|
| **ACC**    | Acumular resultados (parciais e finais) | SaÃ­da da maioria das operaÃ§Ãµes |
| **AUX**    | Guardar o segundo operando da ULA | Apoio para somas, subtraÃ§Ãµes, operaÃ§Ãµes lÃ³gicas |
| **R1,R2,R3** | Armazenar dados de propÃ³sito geral | Fonte de valores para mover ou carregar no AUX |

---

## 6. Registrador de deslocamento?
- âŒ NÃ£o.  
- O **AUX nÃ£o Ã© um registrador de deslocamento** (shift register).  
- Ele Ã© sÃ³ mais um registrador de uso interno para operaÃ§Ãµes.  
- Registradores de deslocamento sÃ£o outro tipo de circuito (servem para mover bits para esquerda/direita).

---

## 7. Resumindo
- Todos (ACC, AUX, R1, R2, R3) sÃ£o **registradores volÃ¡teis** (perdem o conteÃºdo ao desligar).  
- **ACC** = onde o resultado das operaÃ§Ãµes vai parar.  
- **AUX** = apoio, segura o outro valor que a ULA precisa.  
- **R1, R2, R3** = armazenam valores gerais, servem de fonte para mover/copiar.







